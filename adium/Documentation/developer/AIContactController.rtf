{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\froman\fcharset77 Times-Roman;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-Bold;
\f3\froman\fcharset77 Times-Bold;\f4\fswiss\fcharset77 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red128\green0\blue0;}
\pard\qc

\f0\fs32 \cf0 AIContactController\
\pard\ql\qnatural

\fs24 \cf0 \
\pard\ql\qnatural

\f1 \cf0 Adium's contact list is made up of AIContactObjects, or more specifically, subclasses of AIContactObject.  AIContactGroup and AIContactHandle make up the majority of the contact list.\
\
The contact list is a delicate, complicated structure.  Care should be taken to only modify the list using AIContactController's methods. \
\pard\ql\qnatural

\f0 \cf0 \
\
\pard\ql\qnatural

\f2\b \cf2 Contact controller notifications\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (NSNotificationCenter *)
\f3\b contactNotificationCenter
\f0\b0 ;\
\
\pard\tx360\li360\ql\qnatural

\f3\b\fs22 \cf0 Contact_AttributesChanged\
\pard\li720\ql\qnatural
\cf0 Cause:
\f0\b0  A contact object's attributes have changed\

\f3\b Object:
\f0\b0  The contact object (AIContactObject)\

\f3\b UserInfo: \

\f0\b0 @"Keys" - The modified attribute keys (NSArray)\

\f3\b \
\pard\li360\ql\qnatural
\cf0 Contact_StatusChanged\
\pard\li720\ql\qnatural
\cf0 Cause:
\f0\b0  A contact object's status has changed\

\f3\b Object:
\f0\b0  The contact object (AIContactObject)\

\f3\b UserInfo: \

\f0\b0 @"Keys" - The modified status keys (NSArray)\
\
\pard\li360\ql\qnatural

\f3\b \cf0 Contact_OrderChanged\
\pard\li720\ql\qnatural
\cf0 Cause:
\f0\b0  The contact list was re-ordered\

\f3\b Object:
\f0\b0  nil\

\f3\b UserInfo: 
\f0\b0 nil\
\
\pard\li360\ql\qnatural

\f3\b \cf0 Contact_ListChanged\
\pard\li720\ql\qnatural
\cf0 Cause:
\f0\b0  The contact list's content has changed, the whole list should be refreshed.\

\f3\b Object:
\f0\b0  nil\

\f3\b UserInfo: 
\f0\b0 nil
\fs24 \
\pard\ql\qnatural

\f2\b \cf2 \
\
Object ownership & accounts\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (void)
\f3\b addAccount
\f0\b0 :(AIAccount *)inAccount 
\f3\b toObject
\f0\b0 :(AIContactObject *)inObject;\
- (void)
\f3\b removeAccount
\f0\b0 :(AIAccount *)inAccount 
\f3\b fromObject
\f0\b0 :(AIContactObject *)inObject;\
\
\pard\ql\qnatural

\f1 \cf0 Adium's master contact list is stored locally.  As accounts connect, they sync their lists with the Adium master list.  While every object is on the master list, only a selection of them may be on the contact list of a given account.  When an object is on the contact list of an account, it is said to be owned by that account.\
\
A single object may be owned by more than one account, and a single account may (and most likey will) own more than one object.\
\
The ownership of objects can be changed using contactController's addAccount  and removeAccount methods.\
\
The presence of an object on an account can be tested with AIContactObject's:\
\pard\ql\qnatural

\f0 \cf0 - (BOOL)
\f3\b belongsToAccount
\f0\b0 :(AIAccount *)inAccount;\
\pard\ql\qnatural

\f2\b \cf2 \
\
About Groups and Handles\
\pard\ql\qnatural

\f0\b0 \cf0 \
\pard\ql\qnatural

\f1 \cf0 AIContactGroups are contactObjects that store other contact objects.  This means that groups can be placed within groups.  The contact list itself is a group (the root group), containing handles and groups, which may contain additional handles and groups, and so on.  There is no hard cap on nested groups.\
\
To specify the root of the contact list in any of the following methods, pass nil as the group.\
\
The containing group of any contactObject can be retrieved using:\
\pard\ql\qnatural

\f0 \cf0 - (AIContactGroup *)
\f3\b containingGroup
\f0\b0 ;\
\
\pard\ql\qnatural

\f1 \cf0 AIContacthandles are contactObjects that represent an individual user\
\
Contact handles also provide access to their service type and UID:\
\pard\ql\qnatural

\f0 \cf0 - (AIServiceType *)
\f3\b service
\f0\b0 ;\
- (NSString *)
\f3\b UID
\f0\b0 ;\
\pard\ql\qnatural

\f1 \cf0 \
The current name of an object is retrieved using AIContactObject's:\
\pard\ql\qnatural

\f0 \cf0 -(NSString *)
\f3\b displayName
\f0\b0 ;\
\pard\ql\qnatural

\f1 \cf0 \
\pard\ql\qnatural

\f2\b \cf2 \
\
Creating groups and handles\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (AIContactHandle *)
\f3\b createHandleWithService
\f0\b0 :(AIServiceType *)inService 
\f3\b UID
\f0\b0 :(NSString *)inUID 
\f3\b inGroup
\f0\b0 :(AIContactGroup *)inGroup 
\f3\b forAccount
\f0\b0 :(AIAccount *)inAccount;\
- (AIContactGroup *)
\f3\b createGroupNamed
\f0\b0 :(NSString *)inName 
\f3\b inGroup
\f0\b0 :(AIContactGroup *)inGroup;\
- (void)
\f3\b delayContactListUpdatesFor
\f0\b0 :(int)seconds;\
- (BOOL)
\f3\b contactListUpdatesDelayed
\f0\b0 ;\
\
\pard\ql\qnatural

\f1 \cf0 Create groups using the createGroupNamed method, and handles using createHandleWithService.\
\
createHandleWithService requires an AIServiceType (returned by a service controller's 'handleServiceType' method - A list of installed service controllers is available from account controller's availableServiceArray method).  It also requires the desired UID and group, and the account this handle should initially be owned by.\
\
If the handle does not exist on the contact list: it will be created.\
If the handle 
\f4\i does
\f1\i0  exist on the list, in the same group: nothing will happen.\
If the handle 
\f4\i does
\f1\i0  exist on the list, in a different group: an 'out of sync' condition will occur and the user will be prompted for the desired handle location.\
\
In all cases:\
- an AIContactHandle is returned (either the existing one, or a new one).\
- inAccount will be added as an owner for the handle\
\
\pard\ql\qnatural

\f0 \cf0 \
\pard\ql\qnatural

\f2\b \cf2 \
Managing objects\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (void)
\f3\b deleteObject
\f0\b0 :(AIContactObject *)object;\
- (void)
\f3\b renameObject
\f0\b0 :(AIContactObject *)object to
\f3\b :(
\f0\b0 NSString *)newName;\
- (void)
\f3\b moveObject
\f0\b0 :(AIContactObject *)object 
\f3\b toGroup
\f0\b0 :(AIContactGroup *)destGroup 
\f3\b index
\f0\b0 :(int)inIndex;\
\
\pard\ql\qnatural

\f1 \cf0 To move / manage objects at the root of the contact list, use nil as the group.\
\pard\ql\qnatural

\f2\b \cf2 \
\
Accessing & finding objects\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (AIContactGroup *)
\f3\b contactList
\f0\b0 ;\
- (AIContactGroup *)
\f3\b groupWithName
\f0\b0 :(NSString *)inName;\
- (AIContactHandle *)
\f3\b handleWithService
\f0\b0 :(AIServiceType *)inService 
\f3\b UID
\f0\b0 :(NSString *)inUID 
\f3\b forAccount
\f0\b0 :(AIAccount *)inAccount;\
- (NSMutableArray *)
\f3\b allContactsInGroup
\f0\b0 :(AIContactGroup *)inGroup subgroups:(BOOL)subGroups;\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\tx10560\tx11520\tx12480\tx13440\tx14400\tx15360\tx16320\tx17280\tx18240\tx19200\tx20160\tx21120\tx22080\tx23040\tx24000\tx24960\tx25920\tx26880\tx27840\tx28800\tx29760\tx30720\tx31680\tx32640\tx33600\tx34560\tx35520\tx36480\tx37440\tx38400\tx39360\tx40320\tx41280\tx42240\tx43200\tx44160\tx45120\tx46080\tx47040\tx48000\tx48960\tx49920\tx50880\tx51840\tx52800\tx53760\tx54720\tx55680\tx56640\tx57600\tx58560\tx59520\tx60480\tx61440\tx62400\tx63360\tx64320\tx65280\tx66240\tx67200\tx68160\tx69120\tx70080\tx71040\tx72000\tx72960\tx73920\tx74880\tx75840\tx76800\tx77760\tx78720\tx79680\tx80640\tx81600\tx82560\tx83520\tx84480\tx85440\tx86400\tx87360\tx88320\tx89280\tx90240\tx91200\tx92160\tx93120\tx94080\tx95040\tx96000\ql\qnatural
\cf0 - (AIListContact *)
\f3\b contactInGroup
\f0\b0 :(AIListGroup *)inGroup withService:(NSString *)serviceID UID:(NSString *)UID;\
\pard\ql\qnatural
\cf0 \
\pard\ql\qnatural

\f1 \cf0 If you need it, the root contact list group can be retrieved using contactController's contactList method.\
\
Your code is allowed to retain and hold onto the group returned by this method.  However, if this is done, your code 
\f2\b must
\f1\b0  register as an observer to Contact_ListChanged, and 
\f2\b obtain a new reference
\f1\b0  to the contact list in response ot the notification.\
\
\
groupWithName will search the contact list for a group with the passed name.  The placement of the group is not important.  Nil is returned is the group does not exist.\
\
handleWithService searches the contact list for a handle with the passed name and service type.  The placement of the handle is not important.\
If the handle does not exist, it will be created in the strangers group, set as owned by the passed account, and returned.\
\
The implementation details of the strangers group are not important.  All that you need to know is this method always returns the requested contact, even if it doesn't exist on the user's contact list.\
\
allContactsInGroup is useful when building a list of available contacts. It will return an array of all the contacts within the specified group.\
subgroups - if yes, subgroups will be searched as well\
\
for allContactsInGroup and contactIngroup:\
inGroup - the group to search in (nil for the contact list root)\
\pard\ql\qnatural

\f0 \cf0 \
\
\
\pard\ql\qnatural

\f2\b \cf2 \
Object attributes\
\pard\ql\qnatural

\f0\b0 \cf0 \
\pard\ql\qnatural

\f1 \cf0 The display attributes of a contactObject allow multiple pieces of code to work together and determine the best way for displaying contactObjects.\
\
Attributes are stored by key within the individual contact objects. \
\
Since many seperate pieces of code will apply attributes of the same type to the same contact object, attributes are stored in owner arrays, one for each key.  See the owner array documentation for more information on how they work.\
\pard\ql\qnatural

\f2\b \cf2 \
\
\
Displaying objects\
\pard\ql\qnatural

\f0\b0 \cf0 \
\pard\ql\qnatural

\f1 \cf0 The base for displaying all contact objects is the display Name.  Starting with this name as a base, display code can enhance it using the contact object's attributes.  Each attribute is stored in an owner array, and identifier by a key.  While many attributes may appear in the future, the current ones are:\
\
"Hidden" (NSNumber) \
\pard\li360\ql\qnatural
\cf0 YES if the object should not be displayed.  Otherwise NO.\
\pard\ql\qnatural
\cf0 \
"Text Color" (NSColor)\
\pard\li360\ql\qnatural
\cf0 The color of the object's display name string.\
\
\pard\ql\qnatural
\cf0 "Left View" (id <AIHandleLeftView>)\
\pard\li360\ql\qnatural
\cf0 A view to display left of the object's display name string.\
\pard\ql\qnatural
\cf0 \
\
The attribute array for a particular key is retrieved using AIContactObject's:\
\pard\ql\qnatural

\f0 \cf0 - (AIMutableOwnerArray *)displayArrayForKey:(NSString *)inKey;\
\pard\ql\qnatural

\f1 \cf0 \
The owner array can then be averaged/summed (see the owner array docs for more info), and used to alter the display of the object.\
\pard\ql\qnatural

\f2\b \cf2 \
\
\
Altering object display\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (void)
\f3\b objectAttributesChanged
\f0\b0 :(AIContactObject *)inObject 
\f3\b modifiedKeys
\f0\b0 :(NSArray *)inModifiedKeys;\
\pard\ql\qnatural

\f2\b \cf2 \
\pard\ql\qnatural

\f1\b0 \cf0 By adding and removing values in the atribute arrays, any code can modify the appearance of contact objects throughout Adium. \
\
The following code marks 'handle' to display with red text:\
\
\pard\ql\qnatural

\f0 \cf0 AIMutableOwnerArray	*colorArray;\
\
colorArray = [handle displayArrayForKey:@"Text Color"];\
[colorArray removeObjectsWithOwner:self];\
[colorArray addObject:[NSColor redColor] withOwner:self];\
\pard\ql\qnatural

\f1 \cf0 \
Notice that the code first removes any existing objects from the array before adding a new one.  It is advised to only have one object (owned by you) in an array at a time.\
\
After modifying the display attributes, call contact controller's objectAttributesChanged method, passing the keys that have been modified.\
\pard\ql\qnatural

\f2\b \cf2 \
\
\
Object status\
\pard\ql\qnatural

\f0\b0 \cf0 \
\pard\ql\qnatural

\f1 \cf0 AIContactObject's status array allows multiple accounts to set a handle's status.  Status flags are stored by key, and should acurately reflect the contactHandle's current state.\
\
Since many seperate accounts will apply status flags of the same type to the same contact object, they are stored in owner arrays, one for each key.  See the owner array documentation for more information on how they work.\
\
AIContactObject's method:\
- (AIMutableOwnerArray *)statusArrayForKey:(NSString *)inKey;\
returns the status array for a given key.  The currently active status keys are: \
\
"Online" (NSNumber)\
YES if available.\
\
"Warning" (NSNumber)\
% warning level, 0% (no warning) to 100% (full warning)\
\
"Idle" (NSNumber)\
0 if not idle, otherwise number of seconds idle.\
\
"Signon Date" (NSDate)\
The date/time the user became available\
\
"Away" (NSNumber)\
YES if away.\
\
"Client" (NSString)\
A String description of the user's client software\
\
\pard\ql\qnatural

\f0 \cf0 \
\
\pard\ql\qnatural

\f2\b \cf2 Observing status changes, handle observers\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (void)
\f3\b handleStatusChanged
\f0\b0 :(AIContactHandle *)inHandle 
\f3\b modifiedStatusKeys
\f0\b0 :(NSArray *)InModifiedKeys;\
- (void)
\f3\b registerHandleObserver
\f0\b0 :(id)inObserver;\
\
\pard\tx360\tx720\tx1080\tx1440\tx3060\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural

\f1 \cf0 Using AIContactController and a handle observer, plugins can observe status changes in handles.  A handle observer must conform to the AIHandleObserver protocol, which defines the method:\
\pard\tx960\tx1920\tx2880\tx3840\tx4800\tx5760\tx6720\tx7680\tx8640\tx9600\tx10560\tx11520\tx12480\tx13440\tx14400\tx15360\tx16320\tx17280\tx18240\tx19200\tx20160\tx21120\tx22080\tx23040\tx24000\tx24960\tx25920\tx26880\tx27840\tx28800\tx29760\tx30720\tx31680\ql\qnatural

\f0 \cf0 - (NSArray *)
\f3\b updateHandle
\f0\b0 :(AIContactHandle *)inHandle 
\f3\b keys
\f0\b0 :(NSArray *)inModifiedKeys;\
\pard\tx360\tx720\tx1080\tx1440\tx3060\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural

\f1 \cf0 \
When a handle's status is modified, this method is automatically called for all registered observer code.  Passed is the handle being modified, and an array of the keys that are changing.\
\
With the knowledge that something has changed, the handle observer can do whatever it wants as a response.  However, the most common handle observer behavior is to modify the display attributes of the handle that has changed.\
\
If the observed modifies the handle's attributes in response to the status change, it should return an array containing all the modified attribute keys.  If nothing has been modified, return nil.\
\
To register a handle observer, pass it to AIContactController using the registerHandleObserver method.\
\pard\ql\qnatural

\f0 \cf0 \
\
\
\pard\ql\qnatural

\f2\b \cf2 Sorting the contact list\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (void)
\f3\b registerContactSortController
\f0\b0 :(id <AIContactSortController>)inController;\
- (void)
\f3\b sortContactGroup
\f0\b0 :(AIContactGroup *)inGroup 
\f3\b mode
\f0\b0 :(AISortMode)sortMode;\
\
No docs yet, See the alphabetical sort for an example :)\
\
\
\pard\ql\qnatural

\f2\b \cf2 Contact info\
\pard\ql\qnatural

\f0\b0 \cf0 \
- (void)
\f3\b showInfoForContact
\f0\b0 :(AIContactHandle *)inContact;\
- (void)
\f3\b addContactInfoView
\f0\b0 :(AIPreferenceViewController *)inView;\
\
No docs yet, See the alias support for an example :)\
\pard\ql\qnatural

\f2\b \cf2 \
\pard\ql\qnatural

\f0\b0 \cf0 \
}