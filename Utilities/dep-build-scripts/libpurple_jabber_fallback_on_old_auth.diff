#
# old_revision [20e2add42a314b4914e798757eb2a69ac3b491d0]
#
# patch "libpurple/protocols/jabber/auth.c"
#  from [12caf62ded6c3314a811a59f8730fc801420cd8c]
#    to [ec28c44c8f440b6af093275a75cf1868085a0b6d]
# 
# patch "libpurple/protocols/jabber/libxmpp.c"
#  from [e90c78b600e55ee816eae95ffc4c0fd69fdd785b]
#    to [589db9e206bb677d6252063048d96aafa79e7347]
#
============================================================
--- libpurple/protocols/jabber/auth.c	12caf62ded6c3314a811a59f8730fc801420cd8c
+++ libpurple/protocols/jabber/auth.c	ec28c44c8f440b6af093275a75cf1868085a0b6d
@@ -330,14 +330,21 @@ static void jabber_auth_start_cyrus(Jabb
 							disallow_plaintext_auth);
 					g_free(msg);
 					return;
-				/* Everything else has failed, so fail the
-				 * connection. Should probably have a better
-				 * error here.
-				 */
+
 				} else {
-					purple_connection_error_reason (js->gc,
-						PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,
-						_("Server does not use any supported authentication method"));
+					/* We have no mechs which can work.
+					 * Try falling back on the old jabber:iq:auth method. We get here if the server supports
+					 * one or more sasl mechs, we are compiled with cyrus-sasl support, but we support or can connect with none of
+					 * the offerred mechs. jabberd 2.0 w/ SASL and Apple's iChat Server 10.5 both handle and expect
+					 * jabber:iq:auth in this situation.  iChat Server in particular offers SASL GSSAPI by default, which is often
+					 * not configured on the client side, and expects a fallback to jabber:iq:auth when it (predictably) fails.
+					 *
+					 * Note: xep-0078 points out that using jabber:iq:auth after a sasl failure is wrong. However,
+					 * I believe this refers to actual authentication failure, not a simple lack of concordant mechanisms.
+					 * Doing otherwise means that simply compiling with SASL support renders the client unable to connect to servers
+					 * which would connect without issue otherwise. -evands
+					 */
+					jabber_auth_start_old(js);
 					return;
 				}
 				/* not reached */
@@ -452,9 +459,11 @@ jabber_auth_start(JabberStream *js, xmln
 void
 jabber_auth_start(JabberStream *js, xmlnode *packet)
 {
-#ifndef HAVE_CYRUS_SASL
+	/* Adium changes: If the avoid_sasl_for_plain_and_digest_md5_auth pref is TRUE, use built-in digest-md5 and plain if possible.
+	 * This is a workaround since PLAIN is broken on Mac OS X 10.4's sasl installation; digest-md5 is retained to minimize the delta versus
+	 * im.pidgin.pidgin.
+	 */
 	gboolean digest_md5 = FALSE, plain=FALSE;
-#endif
 
 	xmlnode *mechs, *mechnode;
 
@@ -473,47 +482,57 @@ jabber_auth_start(JabberStream *js, xmln
 		return;
 	}
 
-#ifdef HAVE_CYRUS_SASL
 	js->sasl_mechs = g_string_new("");
-#endif
 
 	for(mechnode = xmlnode_get_child(mechs, "mechanism"); mechnode;
 			mechnode = xmlnode_get_next_twin(mechnode))
 	{
 		char *mech_name = xmlnode_get_data(mechnode);
-#ifdef HAVE_CYRUS_SASL
+
 		g_string_append(js->sasl_mechs, mech_name);
 		g_string_append_c(js->sasl_mechs, ' ');
-#else
+
 		if(mech_name && !strcmp(mech_name, "DIGEST-MD5"))
 			digest_md5 = TRUE;
 		else if(mech_name && !strcmp(mech_name, "PLAIN"))
 			plain = TRUE;
-#endif
 		g_free(mech_name);
 	}
 
 #ifdef HAVE_CYRUS_SASL
+if (!purple_prefs_get_bool("/plugins/prpl/jabber/avoid_sasl_for_plain_and_digest_md5_auth"))
+{
+	purple_debug_info("jabber", "using sasl");
+
 	js->auth_type = JABBER_AUTH_CYRUS;
 
 	jabber_sasl_build_callbacks(js);
 
 	jabber_auth_start_cyrus(js);
-#else
+}
+else
+#endif
+{
+	purple_debug_info("jabber", "avoiding sasl for plain/digest md5");
 
 	if(digest_md5) {
 		xmlnode *auth;
 
 		js->auth_type = JABBER_AUTH_DIGEST_MD5;
+#ifdef HAVE_CYRUS_SASL
+		js->sasl_state = SASL_OK;
+#endif
 		auth = xmlnode_new("auth");
 		xmlnode_set_namespace(auth, "urn:ietf:params:xml:ns:xmpp-sasl");
 		xmlnode_set_attrib(auth, "mechanism", "DIGEST-MD5");
-
+		
 		jabber_send(js, auth);
 		xmlnode_free(auth);
 	} else if(plain) {
 		js->auth_type = JABBER_AUTH_PLAIN;
-
+#ifdef HAVE_CYRUS_SASL
+		js->sasl_state = SASL_OK;
+#endif
 		if(js->gsc == NULL && !purple_account_get_bool(js->gc->account, "auth_plain_in_clear", FALSE)) {
 			char *msg = g_strdup_printf(_("%s requires plaintext authentication over an unencrypted connection.  Allow this and continue authentication?"),
 					js->gc->account->username);
@@ -527,14 +546,27 @@ jabber_auth_start(JabberStream *js, xmln
 			g_free(msg);
 			return;
 		}
+
 		finish_plaintext_authentication(js);
 	} else {
+#ifdef HAVE_CYRUS_SASL
+		/* digest_md5 and plain are not options; proceed to attempt cyrus-sasl */
+		purple_debug_info("jabber", "using sasl even though we were avoiding it because no DIGEST_MD5 or PLAIN for this server");
+
+		js->auth_type = JABBER_AUTH_CYRUS;
+	
+		jabber_sasl_build_callbacks(js);
+	
+		jabber_auth_start_cyrus(js);
+#else
 		purple_connection_error_reason (js->gc,
-				PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,
-				_("Server does not use any supported authentication method"));
+										PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,
+										_("Server does not use any supported authentication method"));
+		
+#endif
 	}
-#endif
 }
+}
 
 static void auth_old_result_cb(JabberStream *js, xmlnode *packet, gpointer data)
 {
@@ -563,6 +595,75 @@ static void auth_old_result_cb(JabberStr
 	}
 }
 
+/*!
+ * @brief Given the server challenge (message) and the key (password), calculate the HMAC-MD5 digest
+ *
+ * This is the crammd5 response.  Inspired by cyrus-sasl's _sasl_hmac_md5()
+ */
+static void
+auth_hmac_md5(const char *challenge, size_t challenge_len, const char *key, size_t key_len, guchar *digest)
+{
+	PurpleCipher *cipher;
+	PurpleCipherContext *context;
+	int i;
+	/* inner padding - key XORd with ipad */
+	unsigned char k_ipad[65];    
+	/* outer padding - key XORd with opad */
+	unsigned char k_opad[65];    
+
+	cipher = purple_ciphers_find_cipher("md5");
+
+	/* if key is longer than 64 bytes reset it to key=MD5(key) */
+	if (strlen(key) > 64) {
+		guchar keydigest[16];
+
+		context = purple_cipher_context_new(cipher, NULL);
+		purple_cipher_context_append(context, (const guchar *)key, strlen(key));
+		purple_cipher_context_digest(context, 16, keydigest, NULL);
+		purple_cipher_context_destroy(context);
+
+		key = (char *)keydigest;
+		key_len = 16;
+	} 
+
+	/*
+	 * the HMAC_MD5 transform looks like:
+	 *
+	 * MD5(K XOR opad, MD5(K XOR ipad, text))
+	 *
+	 * where K is an n byte key
+	 * ipad is the byte 0x36 repeated 64 times
+	 * opad is the byte 0x5c repeated 64 times
+	 * and text is the data being protected
+	 */
+
+	/* start out by storing key in pads */
+	memset(k_ipad, '\0', sizeof k_ipad);
+	memset(k_opad, '\0', sizeof k_opad);
+	memcpy(k_ipad, (void *)key, key_len);
+	memcpy(k_opad, (void *)key, key_len);
+
+	/* XOR key with ipad and opad values */
+	for (i=0; i<64; i++) {
+		k_ipad[i] ^= 0x36;
+		k_opad[i] ^= 0x5c;
+	}
+
+	/* perform inner MD5 */
+	context = purple_cipher_context_new(cipher, NULL);
+	purple_cipher_context_append(context, k_ipad, 64); /* start with inner pad */
+	purple_cipher_context_append(context, (const guchar *)challenge, challenge_len); /* then text of datagram */
+	purple_cipher_context_digest(context, 16, digest, NULL); /* finish up 1st pass */
+	purple_cipher_context_destroy(context);
+
+	/* perform outer MD5 */	
+	context = purple_cipher_context_new(cipher, NULL);
+	purple_cipher_context_append(context, k_opad, 64); /* start with outer pad */
+	purple_cipher_context_append(context, digest, 16); /* then results of 1st hash */
+	purple_cipher_context_digest(context, 16, digest, NULL); /* finish up 2nd pass */
+	purple_cipher_context_destroy(context);
+}
+
 static void auth_old_cb(JabberStream *js, xmlnode *packet, gpointer data)
 {
 	JabberIq *iq;
@@ -608,6 +709,35 @@ static void auth_old_cb(JabberStream *js
 			jabber_iq_set_callback(iq, auth_old_result_cb, NULL);
 			jabber_iq_send(iq);
 
+		} else if(js->stream_id && xmlnode_get_child(query, "crammd5")) {
+			const char *challenge;
+			guchar digest[16];
+			char h[17], *p;
+			int i;
+
+			challenge = xmlnode_get_attrib(xmlnode_get_child(query, "crammd5"), "challenge");
+			auth_hmac_md5(challenge, strlen(challenge), pw, strlen(pw), digest);
+
+			/* Create the response query */
+			iq = jabber_iq_new_query(js, JABBER_IQ_SET, "jabber:iq:auth");
+			query = xmlnode_get_child(iq->node, "query");
+
+			x = xmlnode_new_child(query, "username");
+			xmlnode_insert_data(x, js->user->node, -1);
+			x = xmlnode_new_child(query, "resource");
+			xmlnode_insert_data(x, js->user->resource, -1);
+
+			x = xmlnode_new_child(query, "crammd5");
+
+			/* Translate the digest to a hexadecimal notation */
+			p = h;
+			for(i=0; i<16; i++, p+=2)
+				snprintf(p, 3, "%02x", digest[i]);
+			xmlnode_insert_data(x, h, -1);
+
+			jabber_iq_set_callback(iq, auth_old_result_cb, NULL);
+			jabber_iq_send(iq);
+
 		} else if(xmlnode_get_child(query, "password")) {
 			if(js->gsc == NULL && !purple_account_get_bool(js->gc->account,
 						"auth_plain_in_clear", FALSE)) {
@@ -971,11 +1101,15 @@ void jabber_auth_handle_success(JabberSt
 				_("Invalid response from server."));
 		}
 	}
+
+	
 	/* If we've negotiated a security layer, we need to enable it */
-	sasl_getprop(js->sasl, SASL_SSF, &x);
-	if (*(int *)x > 0) {
-		sasl_getprop(js->sasl, SASL_MAXOUTBUF, &x);
-		js->sasl_maxbuf = *(int *)x;
+	if (js->sasl) {
+		sasl_getprop(js->sasl, SASL_SSF, &x);
+		if (*(int *)x > 0) {
+			sasl_getprop(js->sasl, SASL_MAXOUTBUF, &x);
+			js->sasl_maxbuf = *(int *)x;
+		}
 	}
 #endif
 
============================================================
--- libpurple/protocols/jabber/libxmpp.c	e90c78b600e55ee816eae95ffc4c0fd69fdd785b
+++ libpurple/protocols/jabber/libxmpp.c	589db9e206bb677d6252063048d96aafa79e7347
@@ -256,6 +256,10 @@ init_plugin(PurplePlugin *plugin)
 	if ((ret = sasl_client_init(NULL)) != SASL_OK) {
 		purple_debug_error("xmpp", "Error (%d) initializing SASL.\n", ret);
 	}
+	
+	/* Adium hack for Mac OS X 10.4 support */
+	purple_prefs_add_none("/plugins/prpl/jabber");
+	purple_prefs_add_bool("/plugins/prpl/jabber/avoid_sasl_for_plain_and_digest_md5_auth", FALSE);
 #endif
 	jabber_register_commands();
 	
